# 链表

链表和数组的作用相同,  都是用来存储数据。

但数组存在如下缺点：

(1) 数组的大小总是固定的。尽管在 C99 中提供了 VLA ，以及可以使用 reaclloc() 进行动态内存分配。但是那样需要很强的技术。

大多数普通程序员在新建数组时候总是会偷懒选择一个足够大的数量，保证数据都能被存进去。但是这样就会造成两个问题，其一就是空间的严重浪费，再就是当数据规模真的超过我们预先定义的数据规模时整个程序就会出现问题。

(2) 在数组的头部插入数据的代价过大。

链表在数组具有缺陷的地方却很强大。数组是一次分配完全部内存，而链表则是在需要时再分配内存。

**创建数组时，我们会直接分配出所有我们需要的内存。但是对于链表，我们每次只分配出一个节点（node） 的内存。**链表使用指针将各个节点组合到一起，这样就形成了一个连一个的链式的结构

1. 如图 3a 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称**顺序表**）；

2. 如图 3b 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称==链表==）；

   ![image-20210904171200758](图片/image-20210904171200758.png)

* 线性表存储结构可细分为顺序存储结构和链式存储结构
* 使用链表存储的数据元素，**其物理存储位置是随机的**

链表是一种常见的基础数据结构，结构体指针在这里得到了充分的利用。**链表可以动态的进行存储分配**，也就是说，链表是一个功能极为强大的数组，它**可以在节点中定义多种数据类型**，还可以根据需要随意增添，删除，插入节点。

链表操作有很多，比如：链表的创建，修改，删除，插入，输出，排序，反序，清空链表的元素，求链表的长度等等。



## 链表的节点

**链表都有一个头指针head**，它是存放一个地址的普通指针。存储在**栈区**的 head 指向了存储在**堆区**的节点。堆区的节点又互相连接，形成链状的结构。==头指针用于指明链表的位置，便于后期找到链表并使用表中的数据==

链表中的节点分为两类，**头结点和一般节点**。链表中每个节点都分为两部分，==一个数据域，一个是指针域，头结点没有数据域==。

链表头指针head指向第一个元素,  第一个元素又指向第二个元素，…… 直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，**表尾的地址部分放一个“NULL”（表示“空地址”）**，链表到此结束。

![image-20210904182945162](图片/image-20210904182945162.png)

## 链表初始化(创建)

创建一个链表需要做如下工作：

1. 声明一个头指针（如果有必要，可以声明一个头节点）；
2. 创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；

### 例: 创建一个链表存储{1,2,3,4}

```c
#include <stdio.h>
#include <stdlib.h>
//链表中节点的结构
typedef struct Link {
    int  elem;
    struct Link *next;
}link;

//用于输出链表的函数
void display(link *p);
int main() {
    link*p = NULL;
    //初始化链表（1，2，3，4）
    printf("初始化链表为：\n");
    p = initLink();
    display(p);
    return 0;
}

void display(link *p) {
    link* temp = p;//将temp指针重新指向头结点
    //只要temp指针指向的结点的next不是Null，就执行输出语句。
    while (temp) {
        printf("%d ", temp->elem);
        temp = temp->next;
    }
    printf("\n");
}
```

**创建不含头结点的链表 :**

```c

//初始化链表的函数()
link * initLink();

link * initLink() {
    int i;
    link * p = NULL;//创建头指针
    link * temp = (link*)malloc(sizeof(link));//创建首元节点
    //首元节点先初始化
    temp->elem = 1;
    temp->next = NULL;
    p = temp;//头指针指向首元节点
    
    //从第二个节点开始创建
    for (i = 2; i < 5; i++) {
        //创建一个新节点并初始化
        link *a = (link*)malloc(sizeof(link));
        a->elem = i;
        a->next = NULL;
        //将temp节点与新建立的a节点建立逻辑关系
        temp->next = a;
        
    	//指针temp指向新链表的最后一个节点，写temp = a也对
        temp = temp->next;
    }
    //返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表
    return p;
}

```

**创建含头结点的链表 :**

```c
link * initLink(){
    int i;
    link * p = (link*)malloc(sizeof(link));//创建一个头结点
    link * temp = p;//声明一个指针指向头结点，
    //生成链表
    for (i = 1; i < 5; i++) {
        link *a = (link*)malloc(sizeof(link));
        a->elem = i;
        a->next = NULL;
        temp->next = a;
        temp = temp->next;
    }
    return p;
}
```

## 链表插入元素

向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：

- 插入到链表的头部（头节点之后），作为首元节点；
- 插入到链表中间的某个位置；
- 插入到链表的最末端，作为链表中最后一个数据元素；

链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：

1. 将新结点的 next 指针指向插入位置后的结点；

2. 将插入位置**前一结点**的 next 指针指向插入结点；

![image-20210904203901325](图片/image-20210904203901325.png)

==找到插入位置的 前一节点 至关重要==

```c
//p为原链表，elem表示新数据元素，add表示新元素要插入的位置
link * insertElem(link * p, int elem, int add) {
    link * temp = p;//创建临时结点temp
    link * c = NULL;
    int i = 0;
    //首先找到要插入位置的上一个结点
    for (i = 1; i < add; i++) {
        //判断用户输入的插入位置是否有效
        if (temp == NULL) {
            printf("插入位置无效\n");
            return p;
        }
        temp = temp->next;
    }
    //创建插入结点c
    c = (link*)malloc(sizeof(link));
    c->elem = elem;
    //向链表中插入结点
    c->next = temp->next;
    temp->next = c;
    return  p;
}
```

## 链表删除元素

从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除，但作为一名合格的程序员，要对存储空间负责，**对不再利用的存储空间要及时释放**。因此，从链表中删除数据元素需要进行以下 2 步操作：

1. 将结点从链表中摘下来;
2. 手动释放掉结点，回收被结点占用的存储空间;

其中，从链表上摘除某节点的实现非常简单，只需**找到该节点的直接前驱节点 temp**，执行一行程序：

![image-20210904225749176](图片/image-20210904225749176.png)


```c
//p为原链表，add为要删除元素的值
link * delElem(link * p, int add) {
    link * temp = p;
    link * del = NULL;
    int i = 0;
    //temp指向被删除结点的上一个结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
    }
    del = temp->next;//单独设置一个指针指向被删除结点，以防丢失
    temp->next = temp->next->next;//删除某个结点的方法就是更改前一个结点的指针域
    free(del);//手动释放该结点，防止内存泄漏
    return p;
}
```

**注意:** ==遍历有头节点的链表时，需避免头节点对测试数据的影响，因此在遍历链表时，建议使用上面代码中的遍历方法，直接越过头节点对链表进行有效遍历。==

## 链表更新元素

只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可

```c
//更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值
link *amendElem(link * p, int add, int newElem) {
    int i = 0;
    link * temp = p;
    temp = temp->next;//在遍历之前，temp指向首元结点
    //遍历到要更新的结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
    }
    temp->elem = newElem;
    return p;
}
```

