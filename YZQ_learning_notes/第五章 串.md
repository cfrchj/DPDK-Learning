## 第五章 串（还差一节）

### 1.定义

串的定义：由零个或多个字符组成的有限序列，也叫字符串。

- 空串：零个字符串，不包含字符的串，长度为零，用引号 ‘’ 或 ”Φ“ 表示，引号不属于串的内容。
- 空格串：只包含空格的串，空格串是有长度的，空格越多表示的串的越长。
- 子串与主串：串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。
- 子串在主串中的位置就是子串的第一个字符在主串中的序号。
- 串的逻辑结构与线性表类似，但是不同之处在于*串中元素仅由一个字符组成*。

### 2.串的比较

- 串在计算机中的大小取决于它们挨个字母的前后顺序，串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。

- 常用的字符是使用标准的ASCⅡ编码，由7位二进制数表示一个字符，总共可以表示128个字符；后来扩展由8位二进制数表示一个字符，总共可以表示256个字符；后来有了Unicode编码，由16位的二进制数表示一个字符，总共可以表示约6.5万多个字符。

- 两个串相等必须是它们串的长度以及它们各个对应位置的字符都相等时才算是相等。

  1）n<m，且ai=bi(i=1,2,......,n)。比如hap<happy。

   2）存在某个k<=min(m, n)，使得ai=bi(i=1,2,.......,k-1)，ak<bk。比如s="happen"，t="happy"，两串的前4个字母都相同，而两串第5个字母（K值），字母e<y，所以s<t。

### 3.串的存储结构

#### 3.1串的顺序存储结构

1.用一组地址连续的存储单元来存储串中的字符序列的。先预定义大小，为每个定义的串变量分配一个固定长度的存储区，一般是用定长数组来定义。长度有限定。

2.串的顺序存储方式有点问题，如新串的插入有可能使得串序列的长度超过了数组的长度MaxSize。所以对于串的顺序存储，串值的存储空间可在程序执行过程中动态分配。

#### 3.2串的链式存储结构

1.串的数据元素是一个字符，如果应用链表存储串值，一个结点对应一个字符就会造成很大的空间浪费，所以一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满，用“#”或其他非串值字符补全。

2.每个结点存放多少个字符才合适，应该根据实际情况做出选择。

3.串的链式存储结构除了在*连接串与串*操作时有一定的方便，不如顺序存储灵活，性能也没顺序存储好。

### 4.朴素的模式匹配算法

1.子串在主串中的定位操作通常称做串的模式匹配。

2.算法思路：对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成位置。

```
// 朴素的模式匹配法 

// 返回子串T在主串S中第pos个字符开始首次出现的位置。若不存在,则函数返回值为0。 
// 其中,T非空,1≤pos≤StrLength(S)。 
int Index(String S, String T, int pos) 
{
	int i = pos;	// i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配
	int j = 1;				// j用于子串T中当前位置下标值 
	while (i <= S[0] && j <= T[0]) // 若i小于S的长度并且j小于T的长度时，循环继续 
	{
		if (S[i] == T[j]) 	// 两字母相等则继续 
      	{
			++i;
         	++j; 
      	} 
      	else 				// 指针后退重新开始匹配 
      	{  
         	i = i-j+2;		// i退回到上次匹配首位的下一位 
         	j = 1; 			// j退回到子串T的首位 
      	}      
	}
	if (j > T[0]) 
		return i-T[0];
	else 
		return 0;
}
```

3.时间复杂度分析：最好的情况是一开始就匹配成功，如“goodabc”中去匹配“good”，时间复杂度为O(1)；

稍差一些的情况是每次都是首字母就不匹配，则对T串的循环就必须进行了，如“abcdegood”中去匹配“good”，则时间复杂度为O(n+m)，其中n为主串长度，m为要匹配的子串长度。

根据等概率原则，所以这两种情况下的平均时间复杂度为O(n+m)。

最坏的情况就是每次不成功的匹配都发生在串T的最后一个字符，在匹配时，每次都得将T中的字符循环到最后一位才发现根本不匹配。最坏的时间复杂度为：O((n - m) + 1) \* m)

### 5.KMP模式匹配算法

