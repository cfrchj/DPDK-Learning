#### 选择题

1．栈和队列都是(  B  )。
   A.顺序存储的线性结构   B.限制存取点的线性结构
   C.链接存储的线性结构   D.限制存取点的非线性结构
2．一个栈的入栈序列是a，b，c，d，e，则栈的不可能的输出序列是(   C   )。
   A. edcba   B. decba   C. dceab   D. abcde
3．若已知一个栈的入栈序列是l，2，3，…，n，其输出序列为p1，p2，p3，…，pn，若p1=n，则Pi为 (  C   )。
   A.i   B. n-i   C. n-i+l   D.不确定
4．循环队列SQ采用数组空间SQ.data[0，n-1]存放其元素值，已知其头尾指标分别是front和rear，则当前队列中的元素个数是(   A  )。
   A. (rear-front+n)%n    B. rear-front+1
   C. rear-front-1        D. rear-front
5．中缀表达式A-(B+C/D)*E的后缀形式是(  D  )。
   A. AB-C+D／*E*   B. ABC+D／E*
   C. ABCD/E+-   D. ABCD／+E*-

6．一个队列的入列序列是1，2，3，4，则队列的输出序列是( B )。
   A.4，3，2，1    B.1，2，3，4
   C.1，4，3，2    D.3，2，4，1
*7．*若在一个大小为6的数组上实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为(    )。
   A.1和5    B.2和4  C.4和2    D.5和l
8．用不带头结点的单链表存储队列，其队头指针指向队头结点，队尾指标指向队尾结点，则在进行出队运算时( D )。
   A.仅修改队头指针          B.仅修改队尾指针
   C.对头、队尾指针都要修改   D.对头、对尾指针都可能要修改`
   `当队列中只有一个元素时，出队后需要清空对头和队尾指针。
9．若进栈序列为a，b，c，则通过入出栈运算可能得到的a，b，c的不同排列个数为( B )。
   A.4    B.5   C.6    D.7
*10.*设数组data[m]作为循环队列SQ的存储空间，front为队头指针，rear为队尾指针，则执行出队运算后其头指针front值为(  B )。
   A. front=front+l    B. front=(front+l) %(m-l)
   C.front=(front-1)%m    D. front=(front+l)%m

------

#### 简答题

1．什么是队列的“假溢出”现象？一般有哪几种处理方法？

```bash
假设顺序队列的头指针为front，尾指针为rear，队列的容量为MaxSize，下标下界为0，则最后一个单元的下标为MaxSize-1。
(1)“假溢出”是指rear=MaxSize-l，而front≠0的现象。
(2)处理“假溢出”的方法通常有下列3种：
    1)每当从队首删除一个元素时，将队列中剩余的全部元素均向队首方向移动一个位置。
    2)当发生假溢出时，将队列中现有的全部元素均向低下标方向移动一个位置。
    3)上述两种方法都要进行大量元素的移动，效率低。最巧妙的方法是采用循环队列方式。
循环队列是通过头、尾指针的循环来实现的。入队时，修改尾指针：rear=(l+rear)%MaxSize;出队时，修改队首指针：front=(l+front)%MaxSize。
```

2．试证明：若借助栈由输入序列1，2，3，…，n，得到输出序列P1，P2，P3，…，Pn（它是输入序列 的一个排列），则输出序列中不可能出现这样的情况：若i<j<k，存在输出序列Pk Pi Pj。

```undefined
要想得到PkPiPj，则必须先按i，j．k顺序全部进栈以后，再进行出栈操作。
显然，第1个出栈的是最后进栈的Pk，而Pk出栈之后，栈顶元素是Pj，因此第2个出栈的应该是Pj。
最后出栈的才是Pi，即出栈序列应该为PkPjPi，而不是PkPiPj。
```

3．顺序队列一般应该组织成为环状队列的形式，而且一般队列头或尾其中之一应该特殊处理。例如，队列为listarray[O...n-l]，队列头指针为front，队列尾指针为rear，则listarray[rear]表示下一个可以插入队列的位置。请解释其原因。

```undefined
一般环状队列头或尾其中之一要进行特殊处理，否则，当队列“空”或“满”时，只凭q.rear= =q.front无法判断。
一般的处理方法是将q.rear指向下一个要插入的位置。
这样，虽牺牲了一个单元的存储空间，但可以很容易地区分队列“空”或“满”。
当q.rear==q.front时，表示队列“满”，当q.rear==(q.front+l)%n时，表示队列“空”。
```


4.利用两个栈S1和S2模拟一个队列时，要求实现该队列的进队、出队、判队空3种运算。

```cpp
/*
 * 用一个栈S1作为输入栈，另一个栈S2作为输出栈。
 * 进行入队操作时，总是将数据加入到S1中;进行出队操作时，如果S2不空，则输出S2的元素;
 * 如果S2为空，则读取S1的全部元素加入到S2中，然后由S2输出。
 * 当S1和S2均为空时，表示队列为空。
 * 假设栈的类型为STACK
 */

//(1)进队
void EnQueue(STACK *S, ElemType x)
{
    if (SI->top == MaxSize - l)
        printf(¨overflow”);
    else
        Push(Sl，x); 
}
//(2)出队
ElemType DeIQueue(STACK *SI, STACK kS2)
{
    ElemType x;
    if (S2->top ! = -1)
        Pop(S2, &x);
    else
    {
        while (1Empty(S1))
        {
            Pop(S1, &x);
            Push(S2, x);
        }
        Pop(S2, &x);
    }
    return X;
}
//(3)判断队空
int EmptyQueue(STACK *S1, STACK *S2)
{
    if (S1->top == -1 && S2->top == -l)
        return 1; //两个栈同时为空，则表示队空
    return O;     //队不空，返回O
}
```

