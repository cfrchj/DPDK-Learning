第六章 树

#### 一、树的定义

##### 1.树是一种**一对多的数据结构**。

树是n(n>=0)个结点的有限集，当n=0时称为空树。在任意一棵非空树中：

- 有且仅有一个特定的称为**根**的结点；
- 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、......、Tm，其中每一个集合本身又是一棵树，并且称为根的**子树**。

当n>0时，根结点是唯一的，不可能存在多个根结点；

当m>0时，子树的个数没有限制，但它们一定是互不相交的。

##### 2.结点分类：

- 树的结点包含一个数据元素以及若干指向其子树的分支；
- 结点拥有的子树数目称为结点的度；
- 度为0的结点称为叶结点或终端结点；
- 度不为0的结点称为非终端结点或分支结点；
- 除根结点之外，分支结点也称为内部结点；
- 树的度是树内各结点的度的最大值。

##### 3.结点间的关系

结点的子树的根称该结点的孩子（Child），该结点称双亲（Parent），同一双亲的孩子互称兄弟（Sibling），祖先是从根到该结点的任意结点，反之，子树中的任意结点称该结点的子孙。

与双亲同层的结点为堂兄弟，最大层次称树的深度或高度。

结点的各子树有次序为有序树，反之无序树。森林是m棵互不相交的树的集合。子树的集合为森林。

#### 二、树的存储结构

##### 1.双亲表示法

假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示其双亲结点在数组中的位置的元素；

每个结点除了知道自己之外，还知道它的双亲。

一个结点，data是数据域，存储结点的数据信息；parent存储该结点的双亲在数组中的下标。

```C语言
// 树的双亲表示法结点结构定义 
#define MAX_TREE_SIZE 100
typedef int ElemType;  // 树结点的数据类型

// 结点结构
typedef struct PTNode
{
	TElemType data;   // 结点数据
	int parent;      // 双亲位置
}PTNode;
 
// 树结构
typedef struct
{
	PTNode nodes[MAX_TREE_SIZE];   // 结点数组
	int r, n;                    // r：根的位置，n：结点数目
}PTTree;
```

根结点是没有双亲的，所以约定根结点的parent设置为-1；结点最左边孩子的域叫长子域，没有孩子的域设为-1；还可以设置右兄弟域等。可根据需求设计存储结构，非常灵活。如图：

![image-20210908200911439](C:\Users\颜泽卿\AppData\Roaming\Typora\typora-user-images\image-20210908200911439.png)

##### 2.孩子表示法

- 多重链表表示法：由于树中每个结点可能有多棵子树，则可令每个结点有多个指针域，其中每个指针指向一棵子树的根结点。

- 如果采用多重链表表示法，由于树的每个结点孩子个数是不同的，所以可以采用以下两种方案来解决：
  1. 指针域的个数就等于树的度。因为树的度是树各个结点度的最大值。若树中各结点的度相差很大时，是很浪费空间的，因为有很多的结点，它的指针域都是空的。
  2. 结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数。data为数据域，degree为度域，存储该结点的孩子结点的个数，剩下的就是指针域，指向该结点的各个孩子的结点(可变个数)。此种方式克服了空间浪费的缺点，但是由于各个结点的结构是不相同的结构（因为孩子数不一样，指向孩子的指针域个数就不同），加上要维护结点的度的数值，所以在运算上还会带来时间的损耗，这就是以时间换空间。

- 孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空，然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

采用孩子表示法，则需要设计两种结点结构：

1. 孩子链表的孩子结点，child数据域，用来存储某个结点在表头数组中的下标；next指针域，用来存储指向某结点的下一个孩子结点的指针。
2. 表头数组的表头结点，data数据域，存储某结点的数据信息；firstchild头指针域，存储该结点的孩子链表的头指针。

采用孩子表示法的结构定义代码如下：

```c
// 孩子结点
typedef struct CTNode
{
	int child;            // 孩子结点在数组中的下标
	struct CTNode *next;  // 指向下一个孩子结点的指针
}*ChildPtr;
 
// 表头结构
typedef struct
{
	TElemType data;        // 存储树结点的数据
	ChildPtr firstchild;   // 指向第一个孩子的指针
}CTBox;
 
//  树结构
typedef struct
{
	CTBox nodes[MAX_TREE_SIZE];   // 结点数组
	int r, n;                     // r：根的位置，n：结点数目
}CTree;
```

对于查找某结点的孩子、找某结点的兄弟只需查找这个结点的孩子单链表即可；对于遍历整棵树只需对头结点的数组循环即可。如果要知道某结点的双亲，需要整棵树遍历才行。

此时可以把双亲表示法和孩子表示法综合起来，把这种方法称为双亲孩子表示法。如图：

![img](https://img-blog.csdn.net/20140223184515359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2R1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

##### 3.兄弟表示法

任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。所以设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。data是数据域，firstchild为指针域，存储该结点的第一个孩子结点的存储地址，rightsib是指针域，存储该结点的右兄弟结点的存储地址。

```c
// 树的孩子兄弟表示法结构定义
type struct CSNode
{
	TElemType data;
	struct CSNode *firstchild, *rightsib;
}CSNode,*CSTree;
```

![image-20210908204149254](C:\Users\颜泽卿\AppData\Roaming\Typora\typora-user-images\image-20210908204149254.png)

#### 三、二叉树的定义

##### 1.定义

二叉树（Binary Tree）是n(n>=0)个结点的有限集合。该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

##### 2.特点

- 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。没有子树或者有一棵子树都是可以的。
- 左子树和右子树是有顺序的，次序不能任意颠倒。即使树中某结点只有一颗子树，也要区分它是左子树还是右子树。
- 五种基本形态：
  - 空二叉树
  - 只有一个根结点
  - 根结点只有左子树
  - 根结点只有右子树
  - 根结点既有左子树又有右子树

- 三个结点的二叉树有五种形态

##### 3.特殊二叉树

- 斜树：所有的结点都只有左子树的二叉树叫左斜树；所有的结点都只有右子树的二叉树叫右斜树。两者统称为斜树。斜树的每一层都只有一个结点，结点的个数与二叉树的深度相同。

- 满二叉树：所有分支结点都存在左子树和右子树，且所有叶子都在同一层上。

- 完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同。满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满二叉树

  - 完全二叉树的特点：

    - 叶子结点只能出现在最下两层。
    - 最下层的叶子一定集中在左部连续位置。
    - 倒数二层，若有叶子结点，一定都在右部连续位置。
    - 如果结点度为1，则该结点只有左孩子。
    - 同样结点数的二叉树，完全二叉树的深度最小。

    ![image-20210908205411597](C:\Users\颜泽卿\AppData\Roaming\Typora\typora-user-images\image-20210908205411597.png)

#### 四、二叉树的性质

1.在二叉树的第i层上最多有2^(i-1)个结点（i>=1）。

2.深度为k的二叉树最多有2^(k)-1个结点（k>=1）。

3.对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。

4.具有n个结点的完全二叉树的深度为⌊log2n⌋+1（⌊x⌋表示不大于x的最大整数，反过来表示大于x的最小整数）。
5.如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i(1<=i<=n)有：

- 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点⌊i/2⌋。
- 如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。
- 如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1。

#### 五、二叉树的存储结构

1.二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，且结点的存储位置，即数组的下标，要能体现结点之间的逻辑关系，如双亲与孩子的关系等。

2.但对于极端的情况，一棵深度为k的右斜树，它只有k个结点，却需要分配2^(k-1)个存储单元空间，很浪费空间，所以顺序存储结构一般只用于完全二叉树。

3.二叉链表：data是数据域，lchild和rchild都是指针域，分别存放指向左孩子和右孩子的指针。

4.如果有需要还可以增加一个指向其双亲的指针域，那样就称之为三叉链表。

#### 六、遍历二叉树

##### 1.遍历原理

二叉树的遍历是指从根结点出发，按照某种**次序**依次**访问**二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。

##### 2.遍历方法和算法（不为空）

- 前序遍历

先访问根结点，然后前序遍历左子树，再前序遍历右子树。

![img](https://img-blog.csdn.net/20180223122131558)

```
void PreOrderTraverse(BiTree T)
{
	if(T==NULL)
		return;
	printf("%c",T->data);  //显示结点数据
	PreOrderTraverse(T->lchild);   //先序遍历左子树
	PreOrderTraverse(T->rchild);   //先序遍历右子树
}
```



- 中序遍历

从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后再访问根结点，最后中序遍历右子树。

![img](https://img-blog.csdn.net/20180223122302320)

```

//中序
void InOrderTraverse(BiTree T)
{
	if(T==NULL)
		return;
	InOrderTraverse(T->lchild);   //中序遍历左子树
	printf("%c",T->data);  //显示结点数据
	InOrderTraverse(T->rchild);   //中序遍历右子树
}

```

- 后序遍历

从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。

![img](https://img-blog.csdn.net/20180223122410506)

```
//后序
void PostOrderTraverse(BiTree T)
{
	if(T==NULL)
		return;
	PostOrderTraverse(T->lchild);   //后序遍历左子树
	PostOrderTraverse(T->rchild);   //后序遍历右子树
	printf("%c",T->data);  //显示结点数据
}
```

- 层序遍历

从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

把树中的结点变成某种意义的线性序列，便于计算机的处理

##### 3.推导遍历结果：

- 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
- 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
- 已知前序遍历序列和后序遍历序列，不可以唯一确定一棵二叉树。

#### 七、二叉树的建立

​     二叉树的建立采用的是递**归的思想：**给定一个指向根节点的指针，然后递归调用ceate ()函数，自动生成一个二叉树。 就像是在地上挖了个坑（根节点），然后他会拿着铲子（create函数）按照一定的规则自动挖一个很大的洞穴（二叉树）出来。

##### 1.前序遍历

​     采用二叉链表作为其存储结构，为了让每个结点确认是否有左右孩子，将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，如“#”。称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树。

```
// 按前序输入二叉树中结点的值（一个字符）
// #表示空树，构造二叉链表表示二叉树T 
void CreateBiTree(BiTree *T)
{ 
	TElemType ch;
	
	scanf("%c", &ch); 
 
	if(ch == '#') 
	{
		*T = NULL;
	}	
	else
	{
		*T = (BiTree)malloc(sizeof(struct BiTNode));
		if(!*T)
		{
			exit(OVERFLOW);
		}	
		(*T)->data = ch;             // 生成根结点 
		CreateBiTree(&(*T)->lchild); // 构造左子树 
		CreateBiTree(&(*T)->rchild); // 构造右子树 
	}
 }
```

##### 2.中序遍历

但是由于中序遍历不能首先建立根结点，用加“#”的方法是不可能创建一个二叉树的。由扩展后序遍历序列是可以构建出二叉树的，不过不能向前序那样一边输入一边构建，而是先用一个字符数组将扩展后序序列保存下来，然后从最后一位开始向前构建。

```
#include<string.h>
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
# define MAXSIZE 100
int index;
char String[MAXSIZE];

typedef char TElemType;
struct BiTNode
{
	TElemType data;
	struct BiTNode *lchild,*rchild;
};
typedef struct BiTNode *BiTree;

void CreateBiTree(BiTree *T)
{
	TElemType ch = String[--index];
	if(ch=='#')
	{
		*T=NULL;
	}
	else
	{
		*T=(BiTree)malloc(sizeof(struct BiTNode));
		if(!*T)
		{
			exit(OVERFLOW);
		}
		(*T)->data=ch; //生成根结点
		CreateBiTree(&(*T)->lchild);  //构造左子树
		CreateBiTree(&(*T)->rchild);  //构造右子树
	}
}

int main(void)
{
	BiTree T;
	if(scanf("%s",String)!=EOF)
	{
		index=strlen(String);
		CreateBiTree(&T);
	}
	return 0;
}
```

#### 八、线索二叉树

- 有n个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共有2n个指针域；而n个结点的二叉树一共有n-1条分支线数，所以存在的空指针域个数为：`2n-(n-1)=n+1`个。
- 在二叉链表中利用空指针域存放指向结点在某种遍历次序下的前驱和后继结点的地址，把这种*指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为**线索二叉树**。*
- 对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。
- 线索化的实质是将二叉链表中的*空指针改为指向前驱或后继的线索*。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。
- 如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱或后继，则采用线索二叉链表的存储结构很合适。

#### 九、树、森林、二叉树的转换

（图源于[(3条消息) 《大话数据结构》笔记之 第六章 树_漂流在深圳-CSDN博客](https://blog.csdn.net/cdu09/article/details/8966291?spm=1001.2014.3001.5501)）

##### 1.树转换为二叉树

1. 加线：在所有兄弟结点之间加一条连线。
2. 去线：对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。
3. 层次调整：以树的根结点轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。

![img](https://img-blog.csdn.net/20130527145104426)

##### 2.森林转换为二叉树

1. 把每个树转换为二叉树。

2. 第一棵二叉树不动，从第二颗二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。

   ![img](https://img-blog.csdn.net/20130527145208222)

##### 3.二叉树转换为树

1. 加线：若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点.......，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。

2. 去线：删除原二叉树中所有结点与其右孩子结点的连线。

3. 层次调整：使之结构层次分明。

![img](https://img-blog.csdn.net/20130527150123035)

##### 4.二叉树转换为森林

1. 从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除......，直到所有右孩子连线都删除为止，得到分离的二叉树。
2. 将每棵分离后的二叉树转换为树。

![img](https://img-blog.csdn.net/20130527150218050)

#### 十、哈夫曼树

- **路径**：从一个结点到它往下可以达到的结点所经过的所有结点，称为两个结点之间的路径
- **路径长度**：即两个结点的层级差，如A结点在第一层，B结点在第四层，那它们之间的路径长度为4-1=3
- **权重值**：为树中的每个结点设置一个有某种含义的数值，称为权重值(Weight)，权重值在不同算法中可以起到不同的作用
- **结点的带权路径长度**：从根结点到该结点的路径长度与该结点权重值的乘积
- **树的带权路径长度**：所有叶子结点的带权路径长度之和，也简称为**WPL**

**思路分析**：从哈夫曼树的概念中可以看出，要组成哈夫曼树，权值越大的结点必须越靠近根结点，所以在组成哈夫曼树时，应该由最小权值的结点开始。

**步骤**：

1.  结点由小到大进行排序存放在集合中
2.  从结点集合中取出权值最小的两个结点，以这两个结点为结节点创建一棵二叉树，它们的父结点权值就是它们的权值之和
3.  从结点集合中删除取出的两个结点，并将它们组成的父结点添加进结点集合中，跳到步骤(2)直到结点集合中只剩一个结点

